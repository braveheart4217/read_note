## Java并发编程模型
1. **并行工作者模型**
	1. 工作模型
		
		![](http://wiki.jikexueyuan.com/project/java-concurrent/images/1.png)
		1. 委派者（Delegator）将传入的作业分配给不同的工作者
		2. 每个工作者(Worker)完成整个任务。工作者们并行运作在不同的线程上，甚至可能在不同的 CPU 上
	2. 缺点
		1. 共享状态可能会很复杂
			1. 线程需要以某种方式存取共享数据，以确保某个线程的修改能够对其他线程可见（数据修改需要同步到主存中，不仅仅将数据保存在执行这个线程的CPU的缓存中）。线程需要避免竟态，死锁以及很多其他共享状态的并发性问题
			2. 在等待访问共享数据结构时，线程之间的互相等待将会丢失部分并行性。许多并发数据结构是阻塞的，意味着在任何一个时间只有一个或者很少的线程能够访问
			3. [非阻塞并发算法](http://tutorials.jenkov.com/java-concurrency/non-blocking-algorithms.html)也许可以降低竞争并提升性能，但是非阻塞算法的实现比较困难
			4. 可持久化的数据结构[^1]虽然能够解决一部分问题，但是还是不够理想

		2. 无状态的工作者
			1. 共享状态能够被系统中得其他线程修改。所以工作者在每次需要的时候必须重读状态，以确保每次都能访问到最新的副本。工作者无法在内部保存这个状态（每次需要的时候可以重读）称为无状态的
			2. 每次都重读需要的数据，将会导致速度变慢，特别是状态保存在外部数据库中的时候

		3. 任务顺序是不确定的
			1. 并行工作者模式的这种非确定性的特性，使得很难在任何特定的时间点推断系统的状态。这也使得它也更难（如果不是不可能的话）保证一个作业在其他作业之前被执行

2. **流水线模型**
	1. 工作模型
		
		![](http://wiki.jikexueyuan.com/project/java-concurrent/images/3.png)
		1. 每个工作者只负责作业中的部分工作。当完成了自己的这部分工作时工作者会将作业转发给下一个工作者
		2. 每个工作者在自己的线程中运行，并且不会和其他工作者共享状态
		3. 通常使用非阻塞的 IO 来设计使用流水线并发模型的系统，然后可以很好地根据 IO 操作确定工作者之间的状态
	2. 实际的工作模型可能如下:
	
		![](http://wiki.jikexueyuan.com/project/java-concurrent/images/5.png)
		![](http://wiki.jikexueyuan.com/project/java-concurrent/images/6.png)
	3. Actors 和 Channels
		1. Actors 和 channels 是两种比较类似的流水线（或反应器/事件驱动）模型
		2. 在 Actor 模型中每个工作者被称为 actor。Actor 之间可以直接异步地发送和处理消息。Actor 可以被用来实现一个或多个像前文描述的那样的作业处理流水线
			
			![Actor模型](http://wiki.jikexueyuan.com/project/java-concurrent/images/7.png)
		3. Channel 模型中，工作者之间不直接进行通信。相反，它们在不同的通道中发布自己的消息（事件）。其他工作者们可以在这些通道上监听消息，发送者无需知道谁在监听

			![Channel模型](http://wiki.jikexueyuan.com/project/java-concurrent/images/8.png)
	4. 优点
		1. 无需共享的状态
			* 工作者之间无需共享状态，意味着实现的时候无需考虑所有因并发访问共享对象而产生的并发性问题
		2. 有状态的工作者
			* worker 可以在内存中保存它们需要操作的数据，只需在最后将更改写回到外部存储系统。因此，有状态的工作者通常比无状态的工作者具有更高的性能
		3. 较好的硬件整合
			* 单线程代码在整合底层硬件的时候往往具有更好的优势。首先，当能确定代码只在单线程模式下执行的时候，通常能够创建更优化的数据结构和算法
		4. 合理的作用顺序
			* 基于流水线并发模型实现的并发系统，在某种程度上是有可能保证作业的顺序的。作业的有序性使得它更容易地推出系统在某个特定时间点的状态。更进一步，你可以将所有到达的作业写入到日志中去。一旦这个系统的某一部分挂掉了，该日志就可以用来重头开始重建系统当时的状态。

	5. 缺点
		* 流水线并发模型最大的缺点是作业的执行往往分布到多个工作者上，并因此分布到项目中的多个类上。这样导致在追踪某个作业到底被什么代码执行时变得困难
		* 加大了代码编写的难度。有时会将工作者的代码写成回调处理的形式。若在代码中嵌入过多的回调处理，往往会出现所谓的回调地狱（callback hell）现象

3. 函数式并行
	* 基本思想是采用函数调用实现程序。函数可以看作是"代理人（agents）"或者"actor"，函数之间可以像流水线模型那样互相发送消息。某个函数调用另一个函数，这个过程类似于消息发送
	* 函数都是通过拷贝来传递参数的，所以除了接收函数外没有实体可以操作数据。这对于避免共享数据的竞态来说是很有必要的。同样也使得函数的执行类似于原子操作。每个函数调用的执行独立于任何其他函数的调用
	* 函数式并行里面最难的是确定需要并行的那个函数调用

参考记录:

1. [七周并发模型](http://zhouchaowei.com/2015/12/19/%E3%80%8A%E4%B8%83%E5%91%A8%E4%B8%83%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B%E3%80%8B%E7%AC%94%E8%AE%B0-%E5%AF%BC%E5%9B%BE/)
2. [并行谬论](http://www.vaikan.com/the-concurrency-myth/)

[^1]:这里的可持久化数据结构不是指持久化存储，而是一种数据结构，比如 Java 中的 String 类，以及 CopyOnWriteArrayList 类,可以[参考](http://www.cnblogs.com/tedzhao/archive/2008/11/12/1332112.html)


