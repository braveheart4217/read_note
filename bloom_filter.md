Bloom Filter

1. 优点：空间效率和查询时间都远超一般算法

2. 缺点：有一定的误识别率与删除困难

3. 基本概念：

	- bloom filter原理是，当一个元素加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，然后把它们置一，检索时，我们只要看看这些点是不是都是一就（大约）知道他是否在集合中了，如果这些点中有任意一个为0，就表明被检索元素一定不在，如果都是一，则元素很有可能在集合里面。
4. 实例

	假设要你写一个网络爬虫程序（web crawler）。由于网络间的链接错综复杂，爬虫在网络间爬行很可能会形成“环”。为了避免形成“环”，就需要知道爬虫程序已经访问过那些URL。给一个URL，怎样知道爬虫程序是否已经访问过呢？稍微想想，就会有如下几种方案：

		1. 将访问过的URL保存到数据库。

		2. 用HashSet将访问过的URL保存起来。那只需接近O(1)的代价就可以查到一个URL是否被访问过了。

		3. URL经过MD5或SHA-1等单向哈希后再保存到HashSet或数据库。

		4. Bit-Map方法。建立一个BitSet，将每个URL经过一个哈希函数映射到某一位。


　　方法1~3都是将访问过的URL完整保存，方法4则只标记URL的一个映射位。

　　以上方法在数据量较小的情况下都能完美解决问题，但是当数据量变得非常庞大时问题就来了。

- 方法1的缺点：数据量变得非常庞大后关系型数据库查询的效率会变得很低。而且每来一个URL就启动一次数据库查询是不是太小题大做了？

- 方法2的缺点：太消耗内存。随着URL的增多，占用的内存会越来越多。就算只有1亿个URL，每个URL只算50个字符，就需要5GB内存。

- 方法3：由于字符串经过MD5处理后的信息摘要长度只有128Bit，SHA-1处理后也只有160Bit，因此方法3比方法2节省了好几倍的内存。

- 方法4消耗内存是相对较少的，但缺点是单一哈希函数发生冲突的概率太高。还记得数据结构课上学过的Hash表冲突的各种解决方法么？若要降低冲突发生的概率到1%，就要将BitSet的长度设置为URL个数的100倍。

