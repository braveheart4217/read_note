## 原子操作
1. 术语定义

	|名称|英文|解释|
	|--|--|-|
	|缓存行| Cache line | 缓存的最小单位
	|比较并交换| Compare And Swap | CAS操作需要输入两个值(旧值与期望值)，在操作期间先比较旧值是否发生变化，如没有才交换成新值
	|CPU流水线| CPU pipeline | |
	|内存冲突| Memory order violation| 内存冲突一般由假共享内存引起，假共享是指多个CPU同时修改一个缓存行的不同部分而导致其中一个CPU的操作无效，当出现这种情况的时候CPU必须清空流水线

2. 处理器(32位IA-32处理器)通过使用**基于对缓存加锁或者总线加锁**来实现多处理器之间的原子操作
	1. 处理器自动保证基本内存操作的原子性
		* 首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。
	2. 使用总线锁保证原子性
		* 如果多个处理器同时对共享变量进行读改写（i++就是经典的读改写操作）操作，那么共享变量就会被多个处理器同时进行操作，这样读改写操作就不是原子的，操作完之后共享变量的值会和期望的不一致，原因是多个处理器分别从自己的缓存中读取i值，然后进行++操作，然后写回内存，想要**保证读改写共享变量的操作是原子**的，就必须保证CPU1读改写共享变量的时候，CPU2不能操作缓存了该共享变量内存地址的缓存
	3. 使用缓存锁保证原子性
		* 总线锁定把CPU和内存之间通信锁住了，这使得锁定期间，其他处理器不能操作其他内存地址的数据，所以总线锁定的开销比较大，所以就出现了缓存锁
		* 所谓“缓存锁定”就是如果缓存在处理器缓存行中内存区域在LOCK操作期间被锁定，当它执行锁操作回写内存时，处理器不在总线上声言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时会起缓存行无效，在上例中，当CPU1修改缓存行中的i时使用缓存锁定，那么CPU2就不能同时缓存了i的缓存行
		* 两种不会使用缓存锁定的情况
			* 当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line），则处理器会调用总线锁定
			* 处理器不支持

	4. Java实现原子操作
		* 使用循环的CAS操作实现原子操作，例子略
		* CAS操作存在的问题
			* ABA问题
				* 如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了
				* ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么A－B－A 就会变成1A-2B－3A
				* Java1.5开始提供了一个类 `AtomicStampedReference` 来解决ABA问题，其 `compareAndSet` 方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志
			* 循环时间太长的问题
				* 自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销
				* 如果JVM可以支持 `Pause` 指令会使效率有一定程度的提升
					* `pause` 可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源
					* `pause` 可以避免在退出循环的时候因内存顺序冲突`(memory order violation)`而引起CPU流水线被清空`(CPU pipeline flush)`，从而提高CPU的执行效率
			* 只能保证一个共享变量的原子操作
				* Java1.5之后提供 `AtomicReference` 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作
		* 使用锁来实现原子操作
			* 锁机制保证了只有获得锁的线程能够操作锁定的内存区域，所以可以很容易实现原子操作

参考资料:

1.[原子操作实现原理](http://ifeve.com/atomic-operation/) 